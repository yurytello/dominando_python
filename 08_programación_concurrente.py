# -*- coding: utf-8 -*-
"""08 Programación Concurrente.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1T7Jbd6uV9qI4mmqMng2JA7vD6dybjSdW

## Threads

La clase Thread representa una actividad que corre en un hilo de control separado. Hay dos manera de especificar la tarea: pasando un objeto invocable al constructor, o sobrescribiendo el método run() en una subclase.
"""

import threading
import time

# Función que será ejecutada por un hilo
def tarea(nombre, duracion):
    print(f"Iniciando {nombre} {time.strftime('%H:%M:%S', time.gmtime())} .. ")
    time.sleep(duracion)  # Simula un trabajo que toma 'duracion' segundos
    print(f" .. Finalizando {nombre} {time.strftime('%H:%M:%S', time.gmtime())}")

# Crear dos hilos
hilo1 = threading.Thread(target=tarea, args=("Tarea 1", 2))
hilo2 = threading.Thread(target=tarea, args=("Tarea 2", 4))

inicio = time.time()

# Iniciar los hilos
hilo1.start()
hilo2.start()

# Esperar a que los hilos terminen
hilo1.join()
hilo2.join()

fin = time.time()
print(f"Tiempo total de ejecución: {fin - inicio} segundos")

"""## Multiprocessing

El paquete multiprocessing ofrece simultaneidad tanto local como remota, evitando eficazmente el bloqueo del intérprete global (GIL) mediante el uso de subprocesos en lugar de hilos.
"""

from multiprocessing import Pool

def f(x):
    print(f'x: {x} .. ')
    return x**x

#X = [1, 2, 3, 4]
X = range(10)

if __name__ == '__main__':
    with Pool(5) as p:
        print(p.map(f, X))

from multiprocessing import Process
import os

def info(title):
    print(title)
    print('module name:', __name__)
    print('parent process:', os.getppid())
    print('process id:', os.getpid())
    print()

def f(name):
    info('function f')
    print('hello', name)

if __name__ == '__main__':
    info('main line')
    p = Process(target=f, args=('bob',))
    p.start()
    p.join()

"""## Asyncio

asyncio es una biblioteca para escribir código concurrente utilizando la sintaxis async/await.
"""

import asyncio

inicio = time.time()

print("Hello ...")
await asyncio.sleep(3, result=print('... World'))
await asyncio.sleep(6, result=print('... World'))

fin = time.time()
print(f"Tiempo total de ejecución: {fin - inicio} segundos")

import asyncio

# Definir una corutina (función async) que simula una tarea
async def tarea(nombre, duracion):
    print(f"Iniciando {nombre} {time.strftime('%H:%M:%S', time.gmtime())} .. ")
    await asyncio.sleep(duracion)  # Simula un trabajo que toma 'duracion' segundos
    print(f" .. Finalizando {nombre} {time.strftime('%H:%M:%S', time.gmtime())}")

inicio = time.time()

# Crear y ejecutar tareas de forma concurrente
await asyncio.gather(
    tarea("Tarea 1", 3),
    tarea("Tarea 2", 5)
)

fin = time.time()
print(f"Tiempo total de ejecución: {fin - inicio} segundos")